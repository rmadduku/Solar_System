//
//  MyGeometries.cpp - Fall 2022
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//   for the Math 155A project #6.
//


// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include "GL\glew.h" 
#include "GLFW\glfw3.h" 


#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "GlGeomTorus.h"


double HourOfDay = 0.0;
double DayOfYear = 0.0;
double MERDayOfYear = 0.0;
double VENDayOfYear = 0.0;
double MARDayOfYear = 0.0;
double JUPDayOfYear = 0.0;
double SATDayOfYear = 0.0;
double NEPDayOfYear = 0.0;
double URADayOfYear = 0.0;
double PreviousTime = 0.0;

// **********************************
// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
// **********************************
phMaterial materialUnderTexture;

// **************************
// Information for loading textures
// **************************
const int NumTextures = 12;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "sun.bmp",
    "mercury.bmp",
    "venus.bmp",
    "earth_clouds.bmp",
    "moon.bmp",
    "mars.bmp",
    "belt.bmp",
    "jupitermap.bmp",
    "saturn.bmp",
    "rings.bmp",
    "neptune.bmp",
    "uranus.bmp"
};

// *******************************
// For spheres and a cylinder and a torus (Torus is currently not used.)
// *******************************
GlGeomSphere texSphere(4, 4);
GlGeomTorus texTorus(4, 4);
GlGeomTorus beltTorus(4, 4);


// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************


// ********************************************
// This sets up for texture maps. It is called only once
// ********************************************
void SetupForTextures()
{
    // This material goes under the textures.
    // IF YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE FOR DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.9, 0.9, 0.9);
    materialUnderTexture.AmbientColor.Set(0.3, 0.3, 0.3);
    materialUnderTexture.DiffuseColor.Set(0.7, 0.7, 0.7);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    // ***********************************************
    // Load texture maps
    // ***********************************************
    RgbImage texMap;

    glUseProgram(shaderProgramBitmap);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
#if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the shaderProgramBitmap uses the GL_TEXTURE_0 texture.
    glUseProgram(shaderProgramBitmap);
    glUniform1i(glGetUniformLocation(shaderProgramBitmap, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// **********************
// This sets up geometries needed for 
//   (a) the floor (ground plane)
//   (b) the back wall
//   (c) the circular mesh
//   (d) two spheres
//   (e) one cylinder
//  It is called only once.
//  YOU NEED TO CHANGE THIS ONCE YOU ADD THE TEXTURE COORDINATES TO THE CIRCULAR SURFACE.
// **********************
void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    beltTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);




    check_for_opengl_errors();      // Watch the console window for error messages!
}

void MyRemeshGeometries()
{
    // IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
    // YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    texSphere.Remesh(meshRes, meshRes);
    texTorus.Remesh(meshRes, meshRes);
    beltTorus.Remesh(meshRes, meshRes);


    check_for_opengl_errors();      // Watch the console window for error messages!
}

// **********************************************
// MODIFY THIS ROUTINE TO RENDER THE FLOOR, THE BACK WALL,
//    AND THE SPHERES AND THE CYLINDER. -- WITH TEXTURES
// **********************************************

void MyRenderGeometries() {

    float matEntries[16];       // Temporary storage for floats

    // **************
    // Render the circular surface
    selectShaderProgram(shaderProgramBitmap);

    materialUnderTexture.LoadIntoShaders();                       // Use the bright underlying material

    double thisAnimateIncrement = animateIncrement;
    double curTime = glfwGetTime();
    thisAnimateIncrement *= (curTime - PreviousTime) * 60.0;
    PreviousTime = curTime;

    // Update the animation state
    HourOfDay += thisAnimateIncrement;
    DayOfYear += thisAnimateIncrement / 24.0;
    MERDayOfYear += thisAnimateIncrement / 24.0;
    VENDayOfYear += thisAnimateIncrement / 24.0;
    MARDayOfYear += thisAnimateIncrement / 24.0;
    JUPDayOfYear += thisAnimateIncrement / 24.0;
    SATDayOfYear += thisAnimateIncrement / 24.0;
    NEPDayOfYear += thisAnimateIncrement / 24.0;
    URADayOfYear += thisAnimateIncrement / 24.0;

    HourOfDay = HourOfDay - ((int)(HourOfDay / 24)) * 24;       // Wrap back to be in range [0,24)
    DayOfYear = DayOfYear - ((int)(DayOfYear / 365)) * 365;     // Wrap back to be in range [0,365)
    MERDayOfYear = MERDayOfYear - ((int)(MERDayOfYear / 88)) * 88;
    VENDayOfYear = VENDayOfYear - ((int)(VENDayOfYear / 225)) * 225;
    MARDayOfYear = MARDayOfYear - ((int)(MARDayOfYear / 687)) * 687;
    JUPDayOfYear = JUPDayOfYear - ((int)(JUPDayOfYear / 4333)) * 4333;
    SATDayOfYear = SATDayOfYear - ((int)(SATDayOfYear / 10759)) * 10759;
    NEPDayOfYear = NEPDayOfYear - ((int)(NEPDayOfYear / 30687)) * 30687;
    URADayOfYear = URADayOfYear - ((int)(URADayOfYear / 60190)) * 60190;

#if 1

    // Actual values!
    double MERrevolveAngle = (MERDayOfYear / 88.0) * PI2;
    double MERtilt = 0 * PI / 180;
    double MERDay = 4222.6;
    double MERDIA = 4879;
    double MERdis = 0.38;


    double VENrevolveAngle = (VENDayOfYear / 224.7) * PI2;
    double VENtilt = 177.3 * PI / 180;
    double VENDay = 2802;
    double VENDIA = 12104;
    double VENDIS = 0.72;


    double EARTHDIAMETER = 12756;
    double revolveAngle = (DayOfYear / 365.0) * PI2;
    double tilt = 24 * PI / 180;
    double AU = 50+20;

    double moonRotationAngle = (DayOfYear * 12.0 / 365.0) * PI2;

    double MARrevolveAngle = (MARDayOfYear / 687) * PI2;
    double MARtilt = 177.3 * PI / 180;
    double MARDay = 24.7;
    double MARDIA = 6792;
    double MARSDIS = 1.5;

    double JUPrevolveAngle = (JUPDayOfYear / 4331) * PI2;
    double JUPtilt = 3.1 * PI / 180;
    double JUPDay = 9.9;
    double JUPDIA = 142984;
    double JUPDIS = 5.2;

    double SATrevolveAngle = (SATDayOfYear / 10747) * PI2;
    double SATDay = 10.7;
    double SATDIA = 120536;
    double SATDIS = 9.5;
    double SATtilt = 26.7 * PI / 180;

    double URArevolveAngle = (URADayOfYear / 30589) * PI2;
    double URADay = 17.2;
    double URADIA = 51118;
    double URADIS = 19.2;
    double URAtilt = 97.8 * PI / 180;

    double NEPrevolveAngle = (NEPDayOfYear / 59800) * PI2;
    double NEPDay = 16.1;
    double NEPDIA = 49528;
    double NEPDIS = 30.1;
    double NEPtilt = 28.3 * PI / 180;
#else
    double EARTHDIAMETER = 12756;
        double AU = 15 + 4;
    double MERrevolveAngle = (MERDayOfYear / 88.0) * PI2;
    double MERtilt = 0 * PI / 180;
    double MERDay = 4222.6;
    double MERDIA = EARTHDIAMETER*0.8;
    double MERdis = 0.38;


    double VENrevolveAngle = (VENDayOfYear / 224.7) * PI2;
    double VENtilt = 177.3 * PI / 180;
    double VENDay = 2802;
    double VENDIA = EARTHDIAMETER;
    double VENDIS = 0.72;


    double revolveAngle = (DayOfYear / 365.0) * PI2;
    double tilt = 24 * PI / 180;


    double moonRotationAngle = (DayOfYear * 12.0 / 365.0) * PI2;

    double MARrevolveAngle = (MARDayOfYear / 687) * PI2;
    double MARtilt = 177.3 * PI / 180;
    double MARDay = 24.7;
    double MARDIA = EARTHDIAMETER*0.9;
    double MARSDIS = 1.2;

    double JUPrevolveAngle = (JUPDayOfYear / 4331) * PI2;
    double JUPtilt = 3.1 * PI / 180;
    double JUPDay = 9.9;
    double JUPDIA = EARTHDIAMETER*2;
    double JUPDIS = 1.4;

    double SATrevolveAngle = (SATDayOfYear / 10747) * PI2;
    double SATDay = 10.7;
    double SATDIA = EARTHDIAMETER*1.5;
    double SATDIS = 2.2;
    double SATtilt = 26.7 * PI / 180;

    double URArevolveAngle = (URADayOfYear / 30589) * PI2;
    double URADay = 17.2;
    double URADIA = EARTHDIAMETER*1.2;
    double URADIS = 3;
    double URAtilt = 97.8 * PI / 180;

    double NEPrevolveAngle = (NEPDayOfYear / 59800) * PI2;
    double NEPDay = 16.1;
    double NEPDIA = EARTHDIAMETER*1.1;
    double NEPDIS = 3.2;
    double NEPtilt = 28.3 * PI / 180;
#endif





    LinearMapR4 MERPosMatrix = viewMatrix;
    MERPosMatrix.Mult_glRotate(MERrevolveAngle, 0, 1, 0.0);   // Revolve the earth around the sun
    MERPosMatrix.Mult_glTranslate(0.0, 0.0, MERdis * AU);		// Place the earth five units away from the sun

    LinearMapR4 MERMatrix = MERPosMatrix;

    MERMatrix.Mult_glRotate(MERtilt, sin(MERrevolveAngle), 0, -cos(MERrevolveAngle));



    MERMatrix.Mult_glRotate(0, 0.0, 1 * (24 / MERDay), 0);    // Rotate earth on y-axis
    MERMatrix.Mult_glScale(MERDIA/EARTHDIAMETER);                                  // Make radius 0.5.
    MERMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    LinearMapR4 VENPosMatrix = viewMatrix;
    VENPosMatrix.Mult_glRotate(VENrevolveAngle, 0, 1, 0.0);   // Revolve the earth around the sun
    VENPosMatrix.Mult_glTranslate(1.0, 0.0, VENDIS * AU);		// Place the earth five units away from the sun
    LinearMapR4 VENMatrix = VENPosMatrix;
    VENMatrix.Mult_glRotate(VENtilt, sin(VENrevolveAngle), 0, -cos(VENrevolveAngle));
    VENMatrix.Mult_glRotate(0, 0.0, 1 * (24 / VENDay), 0);    // Rotate earth on y-axis
    VENPosMatrix.Mult_glRotate(MERrevolveAngle, 0, 1, (3.4 * PI) / 180);   // orbital tilt
    VENMatrix.Mult_glScale((VENDIA / EARTHDIAMETER));                                  // Make radius 0.5.
    VENMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    LinearMapR4 EarthPosMatrix = viewMatrix;
    EarthPosMatrix.Mult_glRotate(revolveAngle, 0, 1, 0.0);   // Revolve the earth around the sun
    EarthPosMatrix.Mult_glTranslate(0.0, 0.0, AU);		// Place the earth five units away from the sun

    LinearMapR4 EarthMatrix = EarthPosMatrix;
    EarthMatrix.Mult_glRotate(tilt, sin(revolveAngle), 0, -cos(revolveAngle));
    EarthMatrix.Mult_glRotate(0, 0.0, 1, 0);    // Rotate earth on y-axis
    EarthMatrix.Mult_glScale(1);                                  // Make radius 0.5.
    EarthMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    LinearMapR4 MoonMatrix = EarthPosMatrix;        // Base the moon's matrix off the earth's *POS* matrix (EarthPosMatrix)

    MoonMatrix.Mult_glRotate(tilt, sin(revolveAngle), 0, -cos(revolveAngle));
    MoonMatrix.Mult_glRotate(moonRotationAngle, 0.0, 1.0, 0.0);  // Revolving around the earth twelve times per year
    MoonMatrix.Mult_glTranslate(0.0, 0.0, 2.0);	    // Place the Moon one unit away from the earth
    MoonMatrix.Mult_glScale(0.2);                   // Moon has radius 0.2
    MoonMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    LinearMapR4 MARPOS = viewMatrix;
    MARPOS.Mult_glRotate(MARrevolveAngle, 0, 1, 0.0);   // Revolve the earth around the sun
    MARPOS.Mult_glTranslate(0.0, 0.0, MARSDIS*AU);		// Place the earth five units away from the sun

    LinearMapR4 MAR = MARPOS;
    MAR.Mult_glRotate(MARtilt, sin(MARrevolveAngle), 0, -cos(MARrevolveAngle));
    MAR.Mult_glRotate(0, 0.0, 1 * (24 / MARDay), 0);    // Rotate earth on y-axis
    MAR.Mult_glScale((MARDIA/EARTHDIAMETER));                                  // Make radius 0.5.
    MAR.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    MoonMatrix = MARPOS;        // Base the moon's matrix off the earth's *POS* matrix (EarthPosMatrix)

    MoonMatrix.Mult_glRotate(tilt*2, sin(revolveAngle), 0, -cos(revolveAngle));
    MoonMatrix.Mult_glRotate(moonRotationAngle, 0.0, 1.0, 0.0);  // Revolving around the earth twelve times per year
    MoonMatrix.Mult_glTranslate(0.0, 0.0, 2.0);	    // Place the Moon one unit away from the earth
    MoonMatrix.Mult_glScale(0.2);                   // Moon has radius 0.2
    MoonMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    MoonMatrix.Mult_glRotate(tilt * 2, sin(revolveAngle), 0, -cos(revolveAngle));
    MoonMatrix.Mult_glRotate(moonRotationAngle, 0.0, 1.0, 0.0);  // Revolving around the earth twelve times per year
    MoonMatrix.Mult_glTranslate(-2.0, 0.0, 1.0);	    // Place the Moon one unit away from the earth
    MoonMatrix.Mult_glScale(0.4);                   // Moon has radius 0.2
    MoonMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    //add asteroids?

    LinearMapR4 JUPPOS = viewMatrix;
    JUPPOS.Mult_glRotate(JUPrevolveAngle, 0, 1, 0.0);   // Revolve the earth around the sun
    JUPPOS.Mult_glTranslate(0.0, 0.0, JUPDIS* AU);		// Place the earth five units away from the sun

    LinearMapR4 JUP = JUPPOS;
    JUP.Mult_glRotate(JUPtilt, sin(JUPrevolveAngle), 0, -cos(JUPrevolveAngle));
    JUP.Mult_glRotate(0, 0.0, 1 * (24 / JUPDay), 0);    // Rotate earth on y-axis
    JUP.Mult_glScale((JUPDIA / EARTHDIAMETER));                                  // Make radius 0.5.
    JUP.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[7]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    LinearMapR4 SATPOS = viewMatrix;
    SATPOS.Mult_glRotate(SATrevolveAngle, 0, 1, 0.0);   // Revolve the earth around the sun
    SATPOS.Mult_glTranslate(0.0, 0.0, SATDIS* AU);		// Place the earth five units away from the sun

    LinearMapR4 SAT = SATPOS;
    SAT.Mult_glRotate(SATtilt, sin(SATrevolveAngle), 0, -cos(SATrevolveAngle));
    SAT.Mult_glRotate(0, 0.0, 1 * (24 / SATDay), 0);    // Rotate earth on y-axis
    SAT.Mult_glScale((SATDIA / EARTHDIAMETER));                                  // Make radius 0.5.
    SAT.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
   

    // Renders a textured torus in the back left corner.
    LinearMapR4 ring = SATPOS;
    ring.Mult_glScale(SATDIA*2/EARTHDIAMETER);
    ring.Mult_glRotate(SATtilt, sin(SATrevolveAngle), 0, -cos(SATrevolveAngle));
    ring.Mult_glRotate(0, 0.0, 1 * (24 / SATDay), 0);    // Rotate earth on y-axis
    ring.Mult_glScale(1, 0.1, 1);
    ring.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose texture
    glUniform1i(applyTextureLocation, true);            // Enable applying the texture!
    texTorus.Render();                                  // Render the torus
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    LinearMapR4 NEPPOS = viewMatrix;
    NEPPOS.Mult_glRotate(NEPrevolveAngle, 0, 1, 0.0);   // Revolve the earth around the sun
    NEPPOS.Mult_glTranslate(0.0, 0.0, NEPDIS* AU);		// Place the earth five units away from the sun

    LinearMapR4 NEP = NEPPOS;
    NEP.Mult_glRotate(NEPtilt, sin(NEPrevolveAngle), 0, -cos(NEPrevolveAngle));
    NEP.Mult_glRotate(0, 0.0, 1 * (24 / NEPDay), 0);    // Rotate earth on y-axis
    NEP.Mult_glScale((NEPDIA / EARTHDIAMETER));                                  // Make radius 0.5.
    NEP.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[10]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!



    LinearMapR4 URAPOS = viewMatrix;
    URAPOS.Mult_glRotate(URArevolveAngle, 0, 1, 0.0);   // Revolve the earth around the sun
    URAPOS.Mult_glTranslate(0.0, 0.0, URADIS* AU);		// Place the earth five units away from the sun

    LinearMapR4 URA = URAPOS;
    URA.Mult_glRotate(NEPtilt, sin(URArevolveAngle), 0, -cos(URArevolveAngle));
    URA.Mult_glRotate(0, 0.0, 1 * (24 / URADay), 0);    // Rotate earth on y-axis
    URA.Mult_glScale((URADIA / EARTHDIAMETER));                                  // Make radius 0.5.
    URA.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    check_for_opengl_errors();      // Watch the console window for error messages!
}


